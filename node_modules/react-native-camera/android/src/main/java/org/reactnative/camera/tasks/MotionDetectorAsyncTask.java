package org.reactnative.camera.tasks;

import android.util.SparseArray;
import com.google.android.gms.vision.face.Face;
import org.reactnative.frame.RNFrame;
import org.reactnative.frame.RNFrameFactory;
import org.iopan.motiondetector.MotionDetector;

import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.Arguments;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;

import com.google.zxing.BinaryBitmap;
import com.google.zxing.PlanarYUVLuminanceSource;
import  android.renderscript.Allocation;
import  android.renderscript.RenderScript;

import android.content.res.Resources;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import android.os.Environment;

import org.reactnative.camera.utils.RNFileUtils;
import android.util.Log;

public class MotionDetectorAsyncTask extends android.os.AsyncTask<Void, Void, SparseArray<WritableMap>> {
  private byte[] mImageData;
  private int mWidth;
  private int mHeight;
  private int mRotation;
  private MotionDetector mMotionDetector;
  private MotionDetectorAsyncTaskDelegate mDelegate;


  public MotionDetectorAsyncTask(
      MotionDetectorAsyncTaskDelegate delegate,
      MotionDetector motionDetector,
      byte[] imageData,
      int width,
      int height,
      int rotation
  ) {
    mImageData = imageData;
    mWidth = width;
    mHeight = height;
    mRotation = rotation;
    mDelegate = delegate;
    mMotionDetector = motionDetector;
  }

  @Override
  protected SparseArray<WritableMap> doInBackground(Void... ignored) {
    if (isCancelled() || mDelegate == null || mMotionDetector == null || !mMotionDetector.isOperational()) {
      return null;
    }

    SparseArray<WritableMap> maps = new SparseArray<>();
    WritableMap pixel  = Arguments.createMap();
      pixel.putString("color","test Motion");
      pixel.putInt("x",0);
      pixel.putInt("y",0);

    if(mImageData==null){
      pixel.putString("color","mImageData NULL");
      maps.put(0,pixel);
      return maps;
    }


    final int[] rgb = decodeYUV420SP(mImageData, mWidth, mHeight);
    Bitmap bitmap = Bitmap.createBitmap(rgb, mWidth, mHeight, Bitmap.Config.ARGB_8888);

    if(bitmap==null){
      pixel.putString("color","bitmap NULL");
      maps.put(0,pixel);
      return maps;
    }
    bitmap = rotateBitmap(bitmap,90);

    pixel.putString("color","test write");

    String filname;
    filname = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)+ "/test.jpg";


    // //  Save file.
    // try {
    //     // Prepare file output
    //     File imageFile = new File(filname);
    //     imageFile.createNewFile();
    //     FileOutputStream fOut = new FileOutputStream(imageFile);

    //     // Save byte array (it is already a JPEG)
    //     // fOut.write(mImageData);
    //     fOut.write(toJpeg(bitmap, 70));
    //     fOut.flush();
    //     fOut.close();
    //     fOut=null;
    //     // Return file system URI
    

    // } catch (Resources.NotFoundException e) {
    //     pixel.putString("color","Documents directory of the app could not be found."+filname);
    //     maps.put(0,pixel);
    //     return maps;
    // } catch (IOException e) {
    //     pixel.putString("color","An unknown I/O exception has occurred."+filname);
    //     maps.put(0,pixel);
    //     return maps;
    // }

    if(bitmap==null){
      // WritableMap pixel  = Arguments.createMap();
      pixel.putString("color","bitmap NULL");
      maps.put(0,pixel);
      return maps;
    }
      
    // 240x320 pour 99*x132      ratio 2.4242424242  = 80/33
    // 480x640      297x !132   

    // 480x640      198x64
    // 480x640      297x396     ratio 1.6161616161 = 160/99

    // 720x960       495x660
    // 1080x1440      990x132
    // 1080x1440      1080x1440 mais Ã§a rame 2* plus

    // 1080x1440  = 3* (360x480)  360=Screen Width ?

    int bitmapwidth = bitmap.getWidth();
    int bitmapheight = bitmap.getHeight();

    int i = 0;
    int x=0;
    int y=0;
    int step = 3*5;
      for ( x = 0; x < bitmapwidth; x=x+step) {
        for ( y = 0; y < bitmapheight;  y=y+step) {
          WritableMap pixel0  = Arguments.createMap();
          int color = bitmap.getPixel(x, y);
          String hex = Integer.toHexString(color);
          pixel0.putString("color",hex.substring(2));
          pixel0.putInt("x",x);
          pixel0.putInt("y",y);
          maps.put(i,pixel0);
          i++;
        }
      }

  // mMotionDetector.setIndex();
  // if (mMotionDetector.indexMotion>15) {
  //   return null;
  // }

  // pixel.putString("color","img size");
  // pixel.putInt("x",mWidth);
  // pixel.putInt("y",mHeight);
  // maps.put(i,pixel);

    return maps;
  }

  @Override
  protected void onPostExecute(SparseArray<WritableMap> motion) {
    super.onPostExecute(motion);

    if (motion == null) {
      mDelegate.onMotionDetectionError(mMotionDetector);
    } else {
      if (motion.size() > 0) {
        mDelegate.onMotionDetected(motion, mWidth, mHeight, mRotation);
      }
      mDelegate.onMotionDetectingTaskCompleted();
    }
  }

  private static Bitmap toBitmap(byte[] data) {
    try {
        ByteArrayInputStream inputStream = new ByteArrayInputStream(data);
        Bitmap photo = BitmapFactory.decodeStream(inputStream);
        inputStream.close();
        return photo;
    } catch (IOException e) {
        throw new IllegalStateException("Will not happen", e);
    }
  }


  public int[] decodeYUV420SP( byte[] yuv420sp, int width, int height) {   

    final int frameSize = width * height;   

    int rgb[]=new int[width*height];   
    for (int j = 0, yp = 0; j < height; j++) {   
      int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;   
      for (int i = 0; i < width; i++, yp++) {   
        int y = (0xff & ((int) yuv420sp[yp])) - 16;   
        if (y < 0) y = 0;   
        if ((i & 1) == 0) {   
            v = (0xff & yuv420sp[uvp++]) - 128;   
            u = (0xff & yuv420sp[uvp++]) - 128;   
        }   

        int y1192 = 1192 * y;   
        int r = (y1192 + 1634 * v);   
        int g = (y1192 - 833 * v - 400 * u);   
        int b = (y1192 + 2066 * u);   

        if (r < 0) r = 0; else if (r > 262143) r = 262143;   
        if (g < 0) g = 0; else if (g > 262143) g = 262143;   
        if (b < 0) b = 0; else if (b > 262143) b = 262143;   

        rgb[yp] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) | ((b >> 10) & 0xff);   
      }   
    }   
    return rgb;   
  } 



  private static byte[] toJpeg(Bitmap bitmap, int quality) throws OutOfMemoryError {
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);

      try {
          return outputStream.toByteArray();
      } finally {
          try {
              outputStream.close();
          } catch (IOException e) {
              Log.e("IOIO", "problem compressing jpeg", e);
          }
      }
  }

  public static Bitmap rotateBitmap(Bitmap source, float angle){
        Matrix matrix = new Matrix();
        matrix.postRotate(angle);
        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
  }
}

