package org.reactnative.camera.tasks;

import com.google.android.gms.vision.face.Face;
import org.reactnative.frame.RNFrame;
import org.reactnative.frame.RNFrameFactory;
import org.iopan.motiondetector.MotionDetector;

import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.Arguments;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;

import com.google.zxing.BinaryBitmap;
import com.google.zxing.PlanarYUVLuminanceSource;
import  android.renderscript.Allocation;
import  android.renderscript.RenderScript;

import android.content.res.Resources;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import android.os.Environment;

import org.reactnative.camera.utils.RNFileUtils;
import android.util.Log;
import java.lang.Math;
import android.util.Base64;


import android.util.SparseArray;

public class MotionDetectorAsyncTask extends android.os.AsyncTask<Void, Void, WritableMap> {
  private byte[] mImageData;
  private int mWidth;
  private int mHeight;
  private int mViewWidth;
  private int mViewHeight;
  private float mDensity;
  private int mRotation;
  private MotionDetector mMotionDetector;
  private MotionDetectorAsyncTaskDelegate mDelegate;

  private Bitmap motionPixelsFile; // = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf); // this creates a MUTABLE bitmap
  private Bitmap motionPixelsFileToErase;
  private Bitmap motionPixelsFileClean;


private SparseArray<int[]> groupedPixels;  // array of all pixels (position on image)
private int[] motionsGroups;
private int[] pixelGroup; // index = pixel position on image, value = the id of the group that owns that pixel.
private int[] curGroup;
private int iGroup; 
private boolean[][] breadcrumb;
// private int iii =0; 

  public MotionDetectorAsyncTask(
      MotionDetectorAsyncTaskDelegate delegate,
      MotionDetector motionDetector,
      byte[] imageData,
      int width,
      int height,
      int viewWidth,
      int viewHeight,
      float density,
      int rotation
  ) {
    mImageData = imageData;
    mWidth = width;
    mHeight = height;
    mViewWidth = viewWidth;
    mViewHeight = viewHeight;
    mDensity = density;
    mRotation = rotation;
    mDelegate = delegate;
    mMotionDetector = motionDetector;
  }

  @Override
  protected WritableMap doInBackground(Void... ignored) {
    if (mImageData==null || mViewWidth==0 || mViewHeight==0
      || isCancelled() || mDelegate == null || mMotionDetector == null || !mMotionDetector.isOperational()) {
      return null;
    }
    

    WritableMap returnValue  = Arguments.createMap();

    // Debug return.
    // returnValue.putString("pixelRatio", ""+mDensity);
    // returnValue.putString("cap", mWidth+"x"+mHeight);
    // returnValue.putString("view", mViewWidth+"x"+mViewHeight);
    // returnValue.putString("threshold", "" + mMotionDetector.mThreshold);
    // returnValue.putString("sample size", ""+mMotionDetector.mSampleSize);
    // returnValue.putString("Mode",""+mMotionDetector.mMode);
    // returnValue.putString("MinimumPixels",""+mMotionDetector.mMinimumPixels);

    boolean motionDetected = false;
    WritableArray sampledPixels = Arguments.createArray();
    WritableArray motionPixels = Arguments.createArray();

    final int[] rgb = decodeYUV420SP(mImageData, mWidth, mHeight);
    Bitmap bitmap =  Bitmap.createBitmap(rgb, mWidth, mHeight, Bitmap.Config.ARGB_8888);
    if(bitmap==null){
      returnValue.putString("error","bitmap NULL");
      return returnValue;
    }

    int finalWidth = (int)((float)mViewWidth/(mDensity*mMotionDetector.mSampleSize));
    int finalHeight = (int)((float)mViewHeight/(mDensity*mMotionDetector.mSampleSize));


    returnValue.putString("final image Width, Height",bitmap.getWidth()+","+bitmap.getHeight()+" / "+ finalWidth+","+ finalHeight);

    bitmap = Bitmap.createScaledBitmap(
      rotateBitmap(bitmap,90),
      finalWidth, 
      finalHeight,
      false);

    int bitmapWidth = bitmap.getWidth();
    int bitmapHeight = bitmap.getHeight();


    // Scan bitmap.
    if(mMotionDetector.mPreviousSampledValues == null){
      mMotionDetector.mPreviousSampledValues = new int[bitmapWidth*bitmapHeight];
    }

    // Create bitmaps for base64 or file output.
    Bitmap.Config conf = Bitmap.Config.ARGB_8888; // see other conf types
    motionPixelsFile = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf);
    // Bitmap sampledPixelsFile = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf); 
    
    // Lonely motion area in case of non-denoising.
    int xMin = bitmapWidth;
    int xMax = 0;
    int yMin = bitmapHeight;
    int yMax = 0;
    int i = 0;
 
    for ( int x = 0; x < bitmapWidth; x++) {
      for ( int y = 0; y < bitmapHeight; y++) {

        // Check differences with previously stored image.
        int color = bitmap.getPixel(x, y);
        int previousColor = mMotionDetector.mPreviousSampledValues[i];

        int scoreRed = Math.abs(Color.red(previousColor) - Color.red(color)) - Color.red(mMotionDetector.mThreshold);
        int scoreGreen = Math.abs(Color.green(previousColor) - Color.green(color)) - Color.green(mMotionDetector.mThreshold);
        int scoreBlue = Math.abs(Color.blue(previousColor) - Color.blue(color)) - Color.blue(mMotionDetector.mThreshold);
        if (scoreRed>0 || scoreGreen>0 || scoreBlue>0){
          
          motionDetected = true;

          // We can break loop on run-mode if no denoising is requierd.

          int score = Math.max(scoreRed, Math.max(scoreGreen,scoreBlue));
          // score = (255-mMotionDetector.mThreshold) * (score/255); // scale score.

          int finalRed = scoreRed == Math.max(scoreRed, Math.max(scoreGreen,scoreBlue)) ? (0xff) : (0x00);
          int finalGreen = scoreGreen == Math.max(scoreRed, Math.max(scoreGreen,scoreBlue)) ? (0xff) : (0x00);
          int finalBlue = scoreBlue == Math.max(scoreRed, Math.max(scoreGreen,scoreBlue)) ? (0xff) : (0x00);

          if(x>xMax) xMax=x;
          if(x<xMin) xMin=x;
          if(y>yMax) yMax=y;
          if(y<yMin) yMin=y;

          // Store motion pixels for svg output in react side.
          // also used below to for denoising.
          WritableMap pixelMotion = Arguments.createMap();
          pixelMotion.putInt("x",x);
          pixelMotion.putInt("y",y);
          pixelMotion.putInt("color", finalRed<<16 | finalGreen<<8 | finalBlue);
          pixelMotion.putInt("score", score);
          motionPixels.pushMap(pixelMotion);

          // Draw motion bitmap for base64 or file output.
          motionPixelsFile.setPixel(x, y, (score) << 24 | finalRed << 16 | finalGreen << 8 | finalBlue);
        }

        mMotionDetector.mPreviousSampledValues[i] = color;
        i++;
      } // for y
    } // for x

/*
    // Denoising by grouping pixels and then excluding small groups.
    if (motionPixels.size() > 0 && mMotionDetector.mMinimumPixels > 1){
      
      motionPixelsFileClean = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf);
      motionPixelsFileToErase = motionPixelsFile.copy(motionPixelsFile.getConfig(), motionPixelsFile.isMutable() ? true : false);

      breadcrumb = new boolean[bitmapWidth][bitmapHeight];
      motionsGroups = new int[bitmapWidth*bitmapHeight];  //group0 : 5pixels
      groupedPixels = new SparseArray<int[]>(); //bitmapWidth*bitmapHeight
      pixelGroup = new int[bitmapWidth*bitmapHeight]; //  pixelGroup[0] pixel0 : bleong to group 2 
      iGroup=0; // pixelGroup[i] = 0  means pixel i belong to no group;
      WritableArray motionAreas = Arguments.createArray();

      // Scan found motion pixels.
      for (i = 0; i < motionPixels.size(); i++) {

        xMin = bitmapWidth;
        xMax = 0;
        yMin = bitmapHeight;
        yMax = 0;

        iGroup++;
        curGroup =  new int[bitmapWidth*bitmapHeight];

        ReadableMap pixelMotion = Arguments.createMap();
        pixelMotion = motionPixels.getMap(i);

        int x=pixelMotion.getInt("x");
        int y=pixelMotion.getInt("y");
        int score= pixelMotion.getInt("score");

        // in case we already treat that pixel in recursive.
        if(0 != motionPixelsFileToErase.getPixel(x,y)) {

          groupPixel(x, y,4, 0, 0, bitmapWidth, bitmapHeight, motionPixels);
          
          // Erase small groups.
          if(motionsGroups[iGroup] < mMotionDetector.mMinimumPixels){

            int[] toto = groupedPixels.get(iGroup);
            if(toto==null){
              returnValue.putString("TOTO error group" + iGroup, "");
            }
            else{
              // Scan current group and erase pixels from bitmap.
              outerloop:
              for(int iiG = 0 ; iiG<toto.length; iiG++) {
                if (toto[iiG]>0){

                  int gx = toto[iiG]%bitmapWidth;
                  int gy = toto[iiG]/bitmapWidth;

                  // returnValue.putString("scan group "+iGroup, " - x:"+gx +", y:"+gy);

                }
              }            
            }
          }

          // Group is big enougth.
          else{
            int[] toto = groupedPixels.get(iGroup);
            if(toto==null){
              returnValue.putString("TOTO error group" + iGroup, "");
            }
            else{

              // scan current group
              outerloop:
              for(int iiG = 0 ; iiG<toto.length; iiG++) {
                if (toto[iiG]>0){
                   // break outerloop;
                // }

                  int gx = toto[iiG]%bitmapWidth;
                  int gy = toto[iiG]/bitmapWidth;

                  // Fill with color :)
                  if(iGroup%4==0)
                    motionPixelsFileClean.setPixel(gx, gy, (0xff) << 24 | (0xff) << 16 | (0xff) << 8 | (0xff));
                  else if(iGroup%3==0)
                    motionPixelsFileClean.setPixel(gx, gy, (0xff) << 24 | (0x00) << 16 | (0xff) << 8 | (0x00));
                  else if(iGroup%2==0)
                    motionPixelsFileClean.setPixel(gx, gy, (0xff) << 24 | (0xff) << 16 | (0x00) << 8 | (0x00));
                  else
                    motionPixelsFileClean.setPixel(gx, gy, (0xff) << 24 | (0x00) << 16 | (0x00) << 8 | (0xff));
                          
                  if(gx>xMax) xMax=gx;
                  if(gx<xMin) xMin=gx;
                  if(gy>yMax) yMax=gy;
                  if(gy<yMin) yMin=gy;
                }
              }
            }
            returnValue.putString("keep group" + iGroup, x+","+y);
            WritableMap motionArea = Arguments.createMap();
            motionArea.putInt("x",xMin);
            motionArea.putInt("y",yMin);
            motionArea.putInt("w",xMax-xMin+mMotionDetector.mThreshold);
            motionArea.putInt("h",yMax-yMin+mMotionDetector.mThreshold);
            motionAreas.pushMap(motionArea);
          }
        } 
      }
    }
*/

    // // Pixelize sampled bitmap.
    //   Bitmap pixelated  = getPixelatedResizedBitmap(
    //     sampledPixelsFile, 
    //     (int)((float)mViewWidth / mDensity),
    //     (int)((float)mViewHeight / mDensity)
    //   );
    //   //Recycle small, recycle original if no longer needed.
       
    // // Encode sampled bitmap to base64 string.
    //   ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    //   sampledPixelsFile.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
    //   String sampledBase64 = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);


    // Pixelize motion bitmap.
      Bitmap pixelated  = getPixelatedResizedBitmap(
        motionPixelsFile, 
        (int)((float)mViewWidth / mDensity),
        (int)((float)mViewHeight / mDensity)
      );
      //Recycle small, recycle original if no longer needed.

    // Encode motion to base64 string.
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      pixelated.compress(Bitmap.CompressFormat.PNG, 95, outputStream);
      String motionBase64 = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);

    // // Encode motion to base64 string.
    //   outputStream = new ByteArrayOutputStream();
    //   motionPixelsFileClean.compress(Bitmap.CompressFormat.PNG, 95, outputStream);
    //   String motionBase64clean = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);

    // // Save motion bitmap as file.
    //     String filname = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)+ "/test.jpg";
    //     // final File cacheDirectory = mScopedContext.getCacheDirectory();
    //     // String fileName = String.format("%s", new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()));
    //         // if (type == MEDIA_TYPE_IMAGE) {
    //         //     fileName = String.format("IMG_%s.jpg", fileName);

    //   try {
    //       FileOutputStream fOutputStream = new FileOutputStream(filname);
    //       motionPixelsFile.compress(Bitmap.CompressFormat.JPEG, 80, fOutputStream);
    //       fOutputStream.flush();
    //       fOutputStream.close();
    //       fOutputStream = null;
    //       // MediaStore.Images.Media.insertImage(getContentResolver(), file.getAbsolutePath(), file.getName(), file.getName());
    //   } catch (Resources.NotFoundException e) {
    //       returnValue.putString("error","motion Documents directory of the app could not be found."+filname);
    //       return returnValue;
    //   } catch (IOException e) {
    //       returnValue.putString("error","motion An unknown I/O exception has occurred."+filname);
    //       return returnValue;
    //   }




    // returnValue.putString("sampledBase64",sampledBase64);
    // returnValue.putArray("sampled",sampledPixels);

    returnValue.putBoolean("motionDetected",motionDetected); 
    // returnValue.putArray("motionAreas", motionAreas);
    // returnValue.putArray("motionPixels", motionPixels);

    returnValue.putString("motionBase64",motionBase64);
    // returnValue.putString("motionBase64clean",motionBase64clean);


    return returnValue;
  }



  public Bitmap getPixelatedResizedBitmap(Bitmap bm, int newWidth, int newHeight) {
    int width = bm.getWidth();
    int height = bm.getHeight();
    float scaleWidth = ((float) newWidth) / width;
    float scaleHeight = ((float) newHeight) / height;
    // CREATE A MATRIX FOR THE MANIPULATION
    Matrix matrix = new Matrix();
    // RESIZE THE BIT MAP
    matrix.postScale(scaleWidth, scaleHeight);

    // "RECREATE" THE NEW BITMAP
    Bitmap resizedBitmap = Bitmap.createBitmap(
        bm, 0, 0, width, height, matrix, false);
    return resizedBitmap;
  }


  private int groupPixel( int x,int y, int maxDeepth, int commingFrom, int curGroupIndex, int  bitmapWidth, int bitmapHeight, WritableArray sampledPixels){
    breadcrumb[x][y] = true;

    // Directions:
    // 5 1 2
    // 6 0 3
    // 7 8 4
    int[] direction =  {0, 5,    1,    2,    6,      3,    7,    8,    4    };
    int[] xs =         {x, x-1,  x,    x+1,  x-1,    x+1,  x-1,  x,    x+1  };
    int[] ys =         {y, y-1,  y-1,  y-1,  y,      y,    y+1,  y+1,  y+1  };

    for (int i = 1; i<direction.length; i++){
      // ignore out of canvas pixels.
      if(xs[i]>=0 && xs[i]<bitmapWidth && ys[i]>=0 && ys[i]<bitmapHeight){
        // ignore comming from pixel.
        if(commingFrom != direction[i]   && !breadcrumb[xs[i]][ys[i]]  ){ 
          if(0 != motionPixelsFile.getPixel(xs[i],ys[i])) {
            // Found aside pixel in original image...
            groupPixel(xs[i],ys[i], maxDeepth, 9-direction[i] ,curGroupIndex+1, bitmapWidth, bitmapHeight, sampledPixels);             
          }
        }
      }
    }
  
    int currentPixelIndex = x + y*bitmapWidth;

    pixelGroup[currentPixelIndex] = iGroup;
    curGroup[curGroupIndex] = currentPixelIndex;
    groupedPixels.put(iGroup, curGroup);
    motionsGroups[iGroup]++;
    motionPixelsFileToErase.setPixel(x, y, 0);

    return  motionsGroups[iGroup];
  }


  @Override
  protected void onPostExecute(WritableMap motion) {
    super.onPostExecute(motion);

    if (motion == null) {
      mDelegate.onMotionDetectionError(mMotionDetector);
    } else {
      // if (motion.size() > 0) {
        mDelegate.onMotionDetected(motion, mWidth, mHeight, mRotation);
      // }
      mDelegate.onMotionDetectingTaskCompleted();
    }
  }

  public int[] decodeYUV420SP( byte[] yuv420sp, int width, int height) {   

    final int frameSize = width * height;   

    int rgb[]=new int[width*height];   
    for (int j = 0, yp = 0; j < height; j++) {   
      int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;   
      for (int i = 0; i < width; i++, yp++) {   
        int y = (0xff & ((int) yuv420sp[yp])) - 16;   
        if (y < 0) y = 0;   
        if ((i & 1) == 0) {   
            v = (0xff & yuv420sp[uvp++]) - 128;   
            u = (0xff & yuv420sp[uvp++]) - 128;   
        }   

        int y1192 = 1192 * y;   
        int r = (y1192 + 1634 * v);   
        int g = (y1192 - 833 * v - 400 * u);   
        int b = (y1192 + 2066 * u);   

        if (r < 0) r = 0; else if (r > 262143) r = 262143;   
        if (g < 0) g = 0; else if (g > 262143) g = 262143;   
        if (b < 0) b = 0; else if (b > 262143) b = 262143;   

        rgb[yp] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) | ((b >> 10) & 0xff);   
      }   
    }   
    return rgb;   
  } 

  public static Bitmap rotateBitmap(Bitmap source, float angle){
        Matrix matrix = new Matrix();
        matrix.postRotate(angle);
        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
  }
}

