package org.reactnative.camera.tasks;

import com.google.android.gms.vision.face.Face;
import org.reactnative.frame.RNFrame;
import org.reactnative.frame.RNFrameFactory;
import org.iopan.motiondetector.MotionDetector;

import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.Arguments;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;

import com.google.zxing.BinaryBitmap;
import com.google.zxing.PlanarYUVLuminanceSource;
import  android.renderscript.Allocation;
import  android.renderscript.RenderScript;

import android.content.res.Resources;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import android.os.Environment;

import org.reactnative.camera.utils.RNFileUtils;
import android.util.Log;
import java.lang.Math;
import android.util.Base64;


import android.util.SparseArray;

public class MotionDetectorAsyncTask extends android.os.AsyncTask<Void, Void, WritableMap> {
  private byte[] mImageData;
  private int mWidth;
  private int mHeight;
  private int mViewWidth;
  private int mViewHeight;
  private float mDensity;
  private int mRotation;
  private MotionDetector mMotionDetector;
  private MotionDetectorAsyncTaskDelegate mDelegate;

  private Bitmap motionPixelsFile;// = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf); // this creates a MUTABLE bitmap
  private Bitmap motionPixelsFileToErase;
  private Bitmap motionPixelsFileClean;


private SparseArray<int[]> groupedP;
private int[] motionsGroups;
private int[] pixelGroup;
private int[] curGroup;
private int iGroup; 

private boolean[][] tempNotOrph;
private boolean[][] breadcrumb;
private int iii =0; 
  private  WritableMap retunValue  = Arguments.createMap();

  public MotionDetectorAsyncTask(
      MotionDetectorAsyncTaskDelegate delegate,
      MotionDetector motionDetector,
      byte[] imageData,
      int width,
      int height,
      int viewWidth,
      int viewHeight,
      float density,
      int rotation
  ) {
    mImageData = imageData;
    mWidth = width;
    mHeight = height;
    mViewWidth = viewWidth;
    mViewHeight = viewHeight;
    mDensity = density;
    mRotation = rotation;
    mDelegate = delegate;
    mMotionDetector = motionDetector;
  }

  @Override
  protected WritableMap doInBackground(Void... ignored) {
    if (mImageData==null || mViewWidth==0 || mViewHeight==0
      || isCancelled() || mDelegate == null || mMotionDetector == null || !mMotionDetector.isOperational()) {
      return null;
    }
    
    boolean motionDetected = false;
    WritableArray sampledPixels = Arguments.createArray();
    WritableArray motionPixels = Arguments.createArray();

    if(mImageData==null){
      retunValue.putString("error","mImageData NULL");
      return retunValue;
    }

    final int[] rgb = decodeYUV420SP(mImageData, mWidth, mHeight);
    Bitmap bitmap =  Bitmap.createBitmap(rgb, mWidth, mHeight, Bitmap.Config.ARGB_8888);
    if(bitmap==null){
      retunValue.putString("error","bitmap NULL");
      return retunValue;
    }

    bitmap = Bitmap.createScaledBitmap(
      rotateBitmap(bitmap,90),
      (int)((float)mViewWidth/mDensity), 
      (int)((float)mViewHeight/mDensity),
      false);

    int bitmapWidth = bitmap.getWidth();
    int bitmapHeight = bitmap.getHeight();

// // pixelize a bitmap in android
// {
//     Bitmap original = ...;
//     //Calculate proportional size, or make the method accept just a factor of scale.
//     Bitmap small = getResigetResizedBitmap(original, smallWidth, smallHeight);
//     Bitmap pixelated = getResigetResizedBitmap(small, normalWidth, normalHeight);
//    //Recycle small, recycle original if no longer needed.
// }

// public Bitmap getResizedBitmap(Bitmap bm, int newWidth, int newHeight) {
//     int width = bm.getWidth();
//     int height = bm.getHeight();
//     float scaleWidth = ((float) newWidth) / width;
//     float scaleHeight = ((float) newHeight) / height;
//     // CREATE A MATRIX FOR THE MANIPULATION
//     Matrix matrix = new Matrix();
//     // RESIZE THE BIT MAP
//     matrix.postScale(scaleWidth, scaleHeight);

//     // "RECREATE" THE NEW BITMAP
//     Bitmap resizedBitmap = Bitmap.createBitmap(
//         bm, 0, 0, width, height, matrix, false);
//     return resizedBitmap;
// }



    // // Save preview as jpg file.
    // String filname = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)+ "/test.jpg";
    // try {
    //     // Prepare file output
    //     File imageFile = new File(filname);
    //     imageFile.createNewFile();
    //     FileOutputStream fOut = new FileOutputStream(imageFile);

    //     // Save byte array 
    //     // fOut.write(mImageData);
    //     fOut.write(toJpeg(bitmap, 70));
    //     fOut.flush();
    //     fOut.close();
    //     fOut=null;
    //     // Return file system URI
    

    // } catch (Resources.NotFoundException e) {
    //     retunValue.putString("error","Documents directory of the app could not be found."+filname);
    //     return retunValue;
    // } catch (IOException e) {
    //     retunValue.putString("error","An unknown I/O exception has occurred."+filname);
    //     return retunValue;
    // }


    // Scan bitmap.
    // Maybe we shoud check if ViewSize as same ratio than previewImage
    int i = 0;
    int step = mMotionDetector.mSampleSize;
    int ratio = 1;//(int) Math.floor(bitmapHeight / mViewHeight);
    // int xMin = bitmapWidth;
    // int xMax = 0;
    // int yMin = bitmapHeight;
    // int yMax = 0;

    // Previously stored image.
    if(mMotionDetector.mPreviousSampledRedValues == null){
      mMotionDetector.mPreviousSampledRedValues = new int[bitmapWidth*bitmapHeight];
    }

    // // Motion & Sampled bitmap for base64 or file.
    Bitmap.Config conf = Bitmap.Config.ARGB_8888; // see other conf types
    // Bitmap sampledPixelsFile = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf); // this creates a MUTABLE bitmap
    motionPixelsFile = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf); // this creates a MUTABLE bitmap
     motionPixelsFileClean = Bitmap.createBitmap(bitmapWidth, bitmapHeight, conf); // this creates a MUTABLE bitmap

    for ( int x = 0; x < bitmapWidth; x=x+step) {
      for ( int y = 0; y < bitmapHeight; y=y+step) {
        int color = bitmap.getPixel(x, y);//bitmap.getPixel(x*ratio, y*ratio);
        // WritableMap pixel  = Arguments.createMap();
        // String hex = Integer.toHexString(color);
        // pixel.putString("color",hex.substring(2));
        // pixel.putInt("x",x);
        // pixel.putInt("y",y);
        // sampledPixels.pushMap(pixel);

        // // Draw sampled bitmap for base64 or file.
        // for(int xs = 0; xs<step; xs++){
        //   if(x+xs < bitmapWidth){ // Ignore overlapping pixels.
        //     for(int ys = 0; ys<step; ys++){
        //       if( y+ys<bitmapHeight){ // Ignore overlapping pixels.
        //         sampledPixelsFile.setPixel(x+xs, y+ys, color);
        //       }
        //     }
        //   }
        // }

        // Check differences with previously stored image.
        int redValue =  Color.red(color);
        if(Math.abs(mMotionDetector.mPreviousSampledRedValues[i] - redValue) > mMotionDetector.mThreshold){
          motionDetected = true;

          float score = Math.abs(mMotionDetector.mPreviousSampledRedValues[i] - redValue);
          score = (255-mMotionDetector.mThreshold) * (score/255); // scale score.
          // if(x>xMax) xMax=x;
          // if(x<xMin) xMin=x;
          // if(y>yMax) yMax=y;
          // if(y<yMin) yMin=y;

          WritableMap pixelMotion = Arguments.createMap();
          pixelMotion.putInt("x",x);
          pixelMotion.putInt("y",y);
          pixelMotion.putInt("score",(int)score);
          motionPixels.pushMap(pixelMotion);

          // Draw motion bitmap for base64 or file.
          for(int xs = 0; xs<step; xs++){
            if(x+xs < bitmapWidth){ // Ignore overlapping pixels.
              for(int ys = 0; ys<step; ys++){
                if( y+ys<bitmapHeight){ // Ignore overlapping pixels.
                  motionPixelsFile.setPixel(x+xs, y+ys, 
                     ((int)score) << 24 | (0xff) << 16 | (0x00) << 8 | (0x00));
                }
              }
            }
          }
        }
        mMotionDetector.mPreviousSampledRedValues[i] = Color.red(color);
        i++;
      } // for y
    } // for x


// // Denoising.
//      motions = new int[bitmapWidth*bitmapHeight];

//         // Test
//         WritableMap pixelMotion_seul = Arguments.createMap();
//           pixelMotion_seul.putInt("x",step*11);
//           pixelMotion_seul.putInt("y",step*11);
//           pixelMotion_seul.putInt("score",255);
//           motionPixels.pushMap(pixelMotion_seul);

//         WritableMap pixelMotionA = Arguments.createMap();
//           pixelMotionA.putInt("x",step*6);
//           pixelMotionA.putInt("y",step*8);
//           pixelMotionA.putInt("score",255);
//           motionPixels.pushMap(pixelMotionA);

//             WritableMap pixelMotionB = Arguments.createMap();
//                 pixelMotionB.putInt("x",step*5);
//                 pixelMotionB.putInt("y",step*9);
//                 pixelMotionB.putInt("score",255);
//                 motionPixels.pushMap(pixelMotionB);

//               WritableMap pixelMotionB1 = Arguments.createMap();
//                 pixelMotionB1.putInt("x",step*7);
//                 pixelMotionB1.putInt("y",step*9);
//                 pixelMotionB1.putInt("score",255);
//                 motionPixels.pushMap(pixelMotionB1);

//                   WritableMap pixelMotionC = Arguments.createMap();
//                     pixelMotionC.putInt("x",step*6);
//                     pixelMotionC.putInt("y",step*10);
//                     pixelMotionC.putInt("score",255);
//                     motionPixels.pushMap(pixelMotionC);



//           WritableMap pixelMotion0 = Arguments.createMap();
//             pixelMotion0.putInt("x",step*1);  
//             pixelMotion0.putInt("y",0);
//             pixelMotion0.putInt("score",255);
//             motionPixels.pushMap(pixelMotion0);

//           WritableMap pixelMotion1 = Arguments.createMap();
//             pixelMotion1.putInt("x",step*2);
//             pixelMotion1.putInt("y",0);
//             pixelMotion1.putInt("score",255);
//             motionPixels.pushMap(pixelMotion1);

//           WritableMap pixelMotion2 = Arguments.createMap();
//             pixelMotion2.putInt("x",step*6);
//             pixelMotion2.putInt("y",0);
//             pixelMotion2.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2);

//           WritableMap pixelMotion3 = Arguments.createMap();
//             pixelMotion3.putInt("x",step*4);
//             pixelMotion3.putInt("y",0);
//             pixelMotion3.putInt("score",255);
//             motionPixels.pushMap(pixelMotion3);

//           WritableMap pixelMotion4 = Arguments.createMap();
//             pixelMotion4.putInt("x",step*5);
//             pixelMotion4.putInt("y",0);
//             pixelMotion4.putInt("score",255);
//             motionPixels.pushMap(pixelMotion4);


//           WritableMap pixelMotion2_0 = Arguments.createMap();
//             pixelMotion2_0.putInt("x",step*0);  
//             pixelMotion2_0.putInt("y",step*3);
//             pixelMotion2_0.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2_0);

//           WritableMap pixelMotion2_1 = Arguments.createMap();
//             pixelMotion2_1.putInt("x",step*1);
//             pixelMotion2_1.putInt("y",step*3);
//             pixelMotion2_1.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2_1);

//           WritableMap pixelMotion2_2 = Arguments.createMap();
//             pixelMotion2_2.putInt("x",step*2);
//             pixelMotion2_2.putInt("y",step*3);
//             pixelMotion2_2.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2_2);

//           WritableMap pixelMotion2_3 = Arguments.createMap();
//             pixelMotion2_3.putInt("x",step*3);
//             pixelMotion2_3.putInt("y",step*3);
//             pixelMotion2_3.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2_3);

//           WritableMap pixelMotion2_4 = Arguments.createMap();
//             pixelMotion2_4.putInt("x",step*4);
//             pixelMotion2_4.putInt("y",step*3);
//             pixelMotion2_4.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2_4);

//           WritableMap pixelMotion2_5 = Arguments.createMap();
//             pixelMotion2_5.putInt("x",step*5);
//             pixelMotion2_5.putInt("y",step*3);
//             pixelMotion2_5.putInt("score",255);
//             motionPixels.pushMap(pixelMotion2_5);


//           for (int itest = 0; itest<motionPixels.size(); itest++){
            
//             ReadableMap pixelMotionTest = Arguments.createMap();
//             pixelMotionTest = motionPixels.getMap(itest);
//             // retunValue.putString("--debug"+itest, ""+pixelMotionTest.getInt("x") +"-" +pixelMotionTest.getInt("y")); 
// int motionPixelIndex = pixelMotionTest.getInt("x") + pixelMotionTest.getInt("y")*bitmapWidth;
// motions[motionPixelIndex] = ((0xff) << 24 | (0xff) << 16 | (0x00) << 8 | (0x00));

//             for(int xss = 0; xss<step; xss++){
//               if(pixelMotionTest.getInt("x")+xss < bitmapWidth){ // Ignore overlapping pixels.
//                 for(int ys_ = 0; ys_<step; ys_++){
//                   if( pixelMotionTest.getInt("y")+ys_<bitmapHeight){ // Ignore overla
//                     // retunValue.putString("debug i "+itest+" - "+ xss+ ","+ys_, "" + (pixelMotionTest.getInt("x")+xss)+"-" + (pixelMotionTest.getInt("y")+ys_) ); 
//                     motionPixelsFile.setPixel(pixelMotionTest.getInt("x")+xss, pixelMotionTest.getInt("y")+ys_,
//                       (0xff) << 24 | (0xff) << 16 | (0x00) << 8 | (0x00));
//                   }
//                 }
//               }
//             }
//           }

motionPixelsFileToErase = motionPixelsFile.copy(motionPixelsFile.getConfig(), motionPixelsFile.isMutable() ? true : false); 



  breadcrumb = new boolean[bitmapWidth][bitmapHeight];
  tempNotOrph = new boolean[bitmapWidth][bitmapHeight];

motionsGroups = new int[bitmapWidth*bitmapHeight];  //group0 : 5pixels


groupedP = new SparseArray<int[]>(); //bitmapWidth*bitmapHeight
pixelGroup = new int[bitmapWidth*bitmapHeight]; //  pixelGroup[0] pixel0 : bleong to group 2 
iGroup=0; // pixelGroup[i] = 0  means pixel i belong to no group;


 WritableArray motionAreas = Arguments.createArray();

  // if (motionPixels.size() < bitmapWidth/4 * bitmapHeight /4){

    // Scan found motion pixels.
    for (i = 0; i < motionPixels.size(); i++) {

      
      int xMin = bitmapWidth;
      int xMax = 0;
      int yMin = bitmapHeight;
      int yMax = 0;

      iGroup++;
      curGroup =  new int[bitmapWidth*bitmapHeight];

      ReadableMap pixelMotion = Arguments.createMap();
      pixelMotion = motionPixels.getMap(i);

      int x=pixelMotion.getInt("x");
      int y=pixelMotion.getInt("y");
      int score= pixelMotion.getInt("score");

      // in case we already treat that pixel in recursive.
      if(0 != motionPixelsFileToErase.getPixel(x,y)) {

        // isOrphan( int x,int y, int maxDeepth, int commingFrom, int curDeepth, int step, WritableArray sampledPixels)
        groupPixel(x, y,4, 0, 0, step, bitmapWidth, bitmapHeight, motionPixels);
        

        if( motionsGroups[iGroup] < 10 ){

        // if( 4 > isOrphan(x, y,4, 0, 0, step, bitmapWidth, bitmapHeight, motionPixels)){
          // retunValue.putString("erase group" + iGroup, x+","+y);

          int[] toto = groupedP.get(iGroup);
          if(toto==null){
            retunValue.putString("TOTO error group" + iGroup, "");
          }
          else{

            // scan current group
            outerloop:
            for(int iiG = 0 ; iiG<toto.length; iiG++) {
              if (toto[iiG]>0){
                 // break outerloop;
              // }

                int gx = toto[iiG]%bitmapWidth;
                int gy = toto[iiG]/bitmapWidth;

retunValue.putString("scan group "+iGroup, " - x:"+gx +", y:"+gy);

                // fill  sample pixel
                for(int xs = 0; xs<step; xs++){
                  if(gx+xs < bitmapWidth){ // Ignore overlapping pixels.
                    for(int ys = 0; ys<step; ys++){
                      if( gy+ys<bitmapHeight){ // Ignore overlapping pixels.
                       // motionPixelsFileClean.setPixel(gx+xs, gy+ys, (0xff) << 24 | (0x00) << 16 | (0xff) << 8 | (0x00));
                        // !! on check cette couleur dans le récursif !!!
                        // motionPixelsFile.setPixel(x+xs, y+ys, 0);
                      }
                    }
                  }
                }


              }
            }            
          }
        }
        else{
          int[] toto = groupedP.get(iGroup);
          if(toto==null){
            retunValue.putString("TOTO error group" + iGroup, "");
          }
          else{

            // scan current group
            outerloop:
            for(int iiG = 0 ; iiG<toto.length; iiG++) {
              if (toto[iiG]>0){
                 // break outerloop;
              // }

                int gx = toto[iiG]%bitmapWidth;
                int gy = toto[iiG]/bitmapWidth;

                // Fill with color :)
                                // fill  sample pixel
                for(int xs = 0; xs<step; xs++){
                  if(gx+xs < bitmapWidth){ // Ignore overlapping pixels.
                    for(int ys = 0; ys<step; ys++){
                      if( gy+ys<bitmapHeight){ // Ignore overlapping pixels.

                        if(iGroup%4==0)
                          motionPixelsFileClean.setPixel(gx+xs, gy+ys, (0xff) << 24 | (0xff) << 16 | (0xff) << 8 | (0xff));
                        else if(iGroup%3==0)
                          motionPixelsFileClean.setPixel(gx+xs, gy+ys, (0xff) << 24 | (0x00) << 16 | (0xff) << 8 | (0x00));
                        else if(iGroup%2==0)
                          motionPixelsFileClean.setPixel(gx+xs, gy+ys, (0xff) << 24 | (0xff) << 16 | (0x00) << 8 | (0x00));
                        else
                          motionPixelsFileClean.setPixel(gx+xs, gy+ys, (0xff) << 24 | (0x00) << 16 | (0x00) << 8 | (0xff));
                        // !! on check cette couleur dans le récursif !!!
                        // motionPixelsFile.setPixel(x+xs, y+ys, 0);
                      }
                    }
                  }
                }

                if(gx>xMax) xMax=gx;
                if(gx<xMin) xMin=gx;
                if(gy>yMax) yMax=gy;
                if(gy<yMin) yMin=gy;
              }
            }
          }
          retunValue.putString("keep group" + iGroup, x+","+y);
          WritableMap motionArea = Arguments.createMap();
          motionArea.putInt("x",xMin);
          motionArea.putInt("y",yMin);
          motionArea.putInt("w",xMax-xMin+mMotionDetector.mThreshold);
          motionArea.putInt("h",yMax-yMin+mMotionDetector.mThreshold);
          motionAreas.pushMap(motionArea);
        }
      } 
    }
  // }

  for(int ig=1; ig<motionsGroups.length; ig++) {
    if(motionsGroups[ig]>0){
      retunValue.putString("group "+ig, ""+motionsGroups[ig]);
    }
  }

    // Encode motion to base64 string.
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    motionPixelsFile.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
    String motionBase64 = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);

    // Encode motion to base64 string.
    outputStream = new ByteArrayOutputStream();
    motionPixelsFileClean.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
    String motionBase64clean = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);

    // // Encode sampled bitmap to base64 string.
    // ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    // sampledPixelsFile.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
    // String sampledBase64 = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);

    // // Save motion bitmap as file.
    //   String filname = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)+ "/test.jpg";
    //   // final File cacheDirectory = mScopedContext.getCacheDirectory();
    //   // String fileName = String.format("%s", new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()));
    //       // if (type == MEDIA_TYPE_IMAGE) {
    //       //     fileName = String.format("IMG_%s.jpg", fileName);

    // try {
    //     FileOutputStream fOutputStream = new FileOutputStream(filname);
    //     motionPixelsFileSmall.compress(Bitmap.CompressFormat.JPEG, 80, fOutputStream);
    //     fOutputStream.flush();
    //     fOutputStream.close();
    //     fOutputStream = null;
    //     // MediaStore.Images.Media.insertImage(getContentResolver(), file.getAbsolutePath(), file.getName(), file.getName());
    // } catch (Resources.NotFoundException e) {
    //     retunValue.putString("error","motion Documents directory of the app could not be found."+filname);
    //     return retunValue;
    // } catch (IOException e) {
    //     retunValue.putString("error","motion An unknown I/O exception has occurred."+filname);
    //     return retunValue;
    // }


    // Debug return.
    // retunValue.putString("pixelRatio", ""+mDensity);
    // retunValue.putString("threshold", "" + mMotionDetector.mThreshold);
    // retunValue.putString("sample size", ""+mMotionDetector.mSampleSize);
    // retunValue.putString("cap", mWidth+"x"+mHeight);
    // retunValue.putString("view", mViewWidth+"x"+mViewHeight);
    // retunValue.putString("bitmap", bitmapWidth+"x"+bitmapHeight);


    retunValue.putBoolean("motionDetected",motionDetected); 
    retunValue.putArray("motionAreas", motionAreas);
    retunValue.putArray("motionPixels", motionPixels);

    retunValue.putString("motionBase64",motionBase64);
    retunValue.putString("motionBase64clean",motionBase64clean);

    // retunValue.putString("sampledBase64",sampledBase64);
    // retunValue.putArray("sampled",sampledPixels);

    return retunValue;
  }





  private int groupPixel( int x,int y, int maxDeepth, int commingFrom, int curGroupIndex, int step, int  bitmapWidth, int bitmapHeight, WritableArray sampledPixels){

    // Sure we are on a pixel. Link it to its group and and erase it on tmp bitmap.
    int group = iGroup;


    // retunValue.putString(++iii +"groupPixel "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom ,  "curDeepth"+curDeepth   );
   

      // Directions:
      // 5 1 2
      // 6 0 3
      // 7 8 4
      int[] direction =  {0, 5,       1,       2,       6,         3,       7,       8,      4       };
      int[] xs =         {x, x-step,  x,       x+step,  x-step,    x+step,  x-step,  x,       x+step  };
      int[] ys =         {y, y-step,  y-step,  y-step,  y,         y,       y+step,  y+step,  y+step  };


      breadcrumb[x][y] = true;

      outerloop:
      for (int i = 1; i<direction.length; i++){
        // ignore out of canvas pixels.
        if(xs[i]>=0 && xs[i]<bitmapWidth && ys[i]>=0 && ys[i]<bitmapHeight){
          // ignore comming from pixel.
          if(commingFrom != direction[i]   && !breadcrumb[xs[i]][ys[i]]  ){ 
            // retunValue.putString(++iii +"groupPixel "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom +""+" looking at " + direction[i], ""+xs[i]/step+"-"+ys[i]/step );
            
            if(0 != motionPixelsFile.getPixel(xs[i],ys[i])) {
              // found aside pixel in original image...
              // retunValue.putString(++iii +"groupPixel "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom +""+" found at " + direction[i], "" );
        
              // Check if that aside pixel belongs to a group.
              // int asideGroup = pixelGroup[ xs[i] + ys[i]*bitmapWidth ];
              // if(asideGroup > 0){
              //   // yes,
              //   group = asideGroup;
              // }
              // else {
                // no, treat aside pixel.
                groupPixel(xs[i],ys[i], maxDeepth, 9-direction[i] ,curGroupIndex+1, step, bitmapWidth, bitmapHeight, sampledPixels);
              // }
              
            }
          }
        }
      }
    
    

    int currentPixelIndex = x + y*bitmapWidth;

   


    pixelGroup[currentPixelIndex] = group;
    curGroup[curGroupIndex] = currentPixelIndex;

    groupedP.put(group,curGroup);
  
    motionsGroups[group]++;
    motionPixelsFileToErase.setPixel(x, y, 0);


    // retunValue.putString(++iii +"isOrphan "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom , " = " + motionsGroups[iGroup]);
    
    return  motionsGroups[iGroup];
  }



  private int isOrphan( int x,int y, int maxDeepth, int commingFrom, int curDeepth, int step, int  bitmapWidth, int bitmapHeight, WritableArray sampledPixels){

    retunValue.putString(++iii +"isOrphan "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom ,  "curDeepth"+curDeepth   );
         
    // Directions:
    // 5 1 2
    // 6 0 3
    // 7 8 4
    int[] direction =  {0, 5,       1,       2,       6,         3,       7,       8,      4       };
    int[] xs =         {x, x-step,  x,       x+step,  x-step,    x+step,  x-step,  x,       x+step  };
    int[] ys =         {y, y-step,  y-step,  y-step,  y,         y,       y+step,  y+step,  y+step  };

    int asidePixels = 0;

    // if( breadcrumb[x][y] ){
    //   orphean = tempNotOrph[x][y];
    //   return orphean;
    // }
breadcrumb[x][y] = true;

    outerloop:
    for (int i = 1; i<direction.length; i++){
      // ignore out of canvas pixels.
      if(xs[i]>=0 && xs[i]<bitmapWidth && ys[i]>=0 && ys[i]<bitmapHeight){
        // ignore comming from pixel.
        if(commingFrom != direction[i]  /* && !breadcrumb[xs[i]][ys[i]] */ ){ 
          // retunValue.putString(++iii +"isOrphan "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom +""+" looking at " + direction[i], ""+xs[i]/step+"-"+ys[i]/step );
          if(0 != motionPixelsFile.getPixel(xs[i],ys[i])) {
            // found aside pixel...
            asidePixels++;

            retunValue.putString(++iii +"isOrphan "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom +""+" found at " + direction[i], "" );
            
            if (curDeepth == maxDeepth-1 /*&& curDeepth>0*/){  
              
            }
            else {
              asidePixels += isOrphan(xs[i],ys[i], maxDeepth, 9-direction[i] ,curDeepth+1, step, bitmapWidth, bitmapHeight, sampledPixels);
              // boolean next = isOrphan(xs[i],ys[i], maxDeepth, 9-direction[i] ,curDeepth+1, step, bitmapWidth, bitmapHeight, sampledPixels);
              // if (curDeepth == maxDeepth-1 && !next ){  

              // }
              // else{
              //   asidePixels = 
              // }
            }
          }
        }
      }
    }

    // breadcrumb[x][y] =true;
    // if (asidePixels) 
    //   tempNotOrph[x][y] = true;

    retunValue.putString(++iii +"isOrphan "+(x/step)+","+(y/step) +" " +"commingFrom"+commingFrom , " = " + asidePixels );
    return asidePixels;
  }


  @Override
  protected void onPostExecute(WritableMap motion) {
    super.onPostExecute(motion);

    if (motion == null) {
      mDelegate.onMotionDetectionError(mMotionDetector);
    } else {
      // if (motion.size() > 0) {
        mDelegate.onMotionDetected(motion, mWidth, mHeight, mRotation);
      // }
      mDelegate.onMotionDetectingTaskCompleted();
    }
  }

  public int[] decodeYUV420SP( byte[] yuv420sp, int width, int height) {   

    final int frameSize = width * height;   

    int rgb[]=new int[width*height];   
    for (int j = 0, yp = 0; j < height; j++) {   
      int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;   
      for (int i = 0; i < width; i++, yp++) {   
        int y = (0xff & ((int) yuv420sp[yp])) - 16;   
        if (y < 0) y = 0;   
        if ((i & 1) == 0) {   
            v = (0xff & yuv420sp[uvp++]) - 128;   
            u = (0xff & yuv420sp[uvp++]) - 128;   
        }   

        int y1192 = 1192 * y;   
        int r = (y1192 + 1634 * v);   
        int g = (y1192 - 833 * v - 400 * u);   
        int b = (y1192 + 2066 * u);   

        if (r < 0) r = 0; else if (r > 262143) r = 262143;   
        if (g < 0) g = 0; else if (g > 262143) g = 262143;   
        if (b < 0) b = 0; else if (b > 262143) b = 262143;   

        rgb[yp] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) | ((b >> 10) & 0xff);   
      }   
    }   
    return rgb;   
  } 

  public static Bitmap rotateBitmap(Bitmap source, float angle){
        Matrix matrix = new Matrix();
        matrix.postRotate(angle);
        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
  }
}

