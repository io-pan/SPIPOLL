package org.iopan.motiondetector;

import android.content.Context;
import android.util.SparseArray;

import org.reactnative.camera.utils.ImageDimensions;
import com.google.android.gms.vision.face.Face;
// import com.google.android.gms.vision.face.FaceDetector;
import org.reactnative.frame.RNFrame;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.WritableMap;

public class MotionDetector {
  // public static int ALL_CLASSIFICATIONS = FaceDetector.ALL_CLASSIFICATIONS;
  // public static int NO_CLASSIFICATIONS = FaceDetector.NO_CLASSIFICATIONS;
  // public static int ALL_LANDMARKS = FaceDetector.ALL_LANDMARKS;
  // public static int NO_LANDMARKS = FaceDetector.NO_LANDMARKS;
  // public static int ACCURATE_MODE = FaceDetector.ACCURATE_MODE;
  // public static int FAST_MODE = FaceDetector.FAST_MODE;

  private boolean mFaceDetector = false; // private FaceDetector mFaceDetector = null;
  private ImageDimensions mPreviousDimensions;
  // private FaceDetector.Builder mBuilder = null;

  // private int mClassificationType = NO_CLASSIFICATIONS;
  private int mLandmarkType = 0;//NO_LANDMARKS;
  // private float mMinFaceSize = 0.15f;
  private int mMode = 1;

  public int indexMotion = 0;

  public MotionDetector(Context context) {
    // mBuilder = new FaceDetector.Builder(context);
    // mBuilder.setMinFaceSize(mMinFaceSize);
    // mBuilder.setMode(mMode);
    // mBuilder.setLandmarkType(mLandmarkType);
    // mBuilder.setClassificationType(mClassificationType);
  }

  // Public API
  public void setIndex() {
    indexMotion++;    // if (mFaceDetector == null) {
    //    mFaceDetector = mBuilder.build();
    // }

    // return mFaceDetector.isOperational();
  }

  public boolean isOperational() {
    // if (mFaceDetector == null) {
    //    mFaceDetector = mBuilder.build();
    // }

    // return mFaceDetector.isOperational();
    return true;
  }

  // DETECT
  public SparseArray<WritableMap> detect(RNFrame frame) {
    // If the frame has different dimensions, create another face detector.
    // Otherwise we will get nasty "inconsistent image dimensions" error from detector
    // and no face will be detected.
    // if (!frame.getDimensions().equals(mPreviousDimensions)) {
    //   releaseMotionDetector();
    // }

    if (mFaceDetector == false) {
       // mFaceDetector = mBuilder.build();
      mPreviousDimensions = frame.getDimensions();
    }

    
    SparseArray<WritableMap> maps = new SparseArray<>();
      WritableMap map = Arguments.createMap();
      map.putString("motion"," motion. detect");

    maps.put(0,map);
    return maps;
  
    // return mFaceDetector.detect(frame.getFrame());
  }

  public void setTracking(boolean trackingEnabled) {
    release();
    // mBuilder.setTrackingEnabled(trackingEnabled);
  }

  // public void setClassificationType(int classificationType) {
  //   if (classificationType != mClassificationType) {
  //     release();
  //     mBuilder.setClassificationType(classificationType);
  //     mClassificationType = classificationType;
  //   }
  // }

  public void setLandmarkType(int landmarkType) {
    if (landmarkType != mLandmarkType) {
      release();
      // mBuilder.setLandmarkType(landmarkType);
      mLandmarkType = landmarkType;
    }
  }

  public void setMode(int mode) {
    if (mode != mMode) {
      release();
      // mBuilder.setMode(mode);
      mMode = mode;
    }
  }

  public void setTrackingEnabled(boolean tracking) {
    release();
    // mBuilder.setTrackingEnabled(tracking);
  }

  public void release() {
    releaseMotionDetector();
    mPreviousDimensions = null;
  }

  // // Lifecycle methods

  private void releaseMotionDetector() {
    if (mFaceDetector != false) {
      mFaceDetector = false;//mFaceDetector.release();
  //     mFaceDetector = null;
    }
  }


}
